{"/home/travis/build/npmtest/node-npmtest-webtorrent/test.js":"/* istanbul instrument in package npmtest_webtorrent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-webtorrent/lib.npmtest_webtorrent.js":"/* istanbul instrument in package npmtest_webtorrent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_webtorrent = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_webtorrent = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-webtorrent/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-webtorrent && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_webtorrent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_webtorrent\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_webtorrent.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_webtorrent.rollup.js'] =\n            local.assetsDict['/assets.npmtest_webtorrent.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_webtorrent.__dirname + '/lib.npmtest_webtorrent.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/index.js":"/* global FileList */\n\nmodule.exports = WebTorrent\n\nvar Buffer = require('safe-buffer').Buffer\nvar concat = require('simple-concat')\nvar createTorrent = require('create-torrent')\nvar debug = require('debug')('webtorrent')\nvar DHT = require('bittorrent-dht/client') // browser exclude\nvar EventEmitter = require('events').EventEmitter\nvar extend = require('xtend')\nvar inherits = require('inherits')\nvar loadIPSet = require('load-ip-set') // browser exclude\nvar parallel = require('run-parallel')\nvar parseTorrent = require('parse-torrent')\nvar path = require('path')\nvar Peer = require('simple-peer')\nvar randombytes = require('randombytes')\nvar speedometer = require('speedometer')\nvar zeroFill = require('zero-fill')\n\nvar TCPPool = require('./lib/tcp-pool') // browser exclude\nvar Torrent = require('./lib/torrent')\n\n/**\n * WebTorrent version.\n */\nvar VERSION = require('./package.json').version\n\n/**\n * Version number in Azureus-style. Generated from major and minor semver version.\n * For example:\n *   '0.16.1' -> '0016'\n *   '1.2.5' -> '0102'\n */\nvar VERSION_STR = VERSION.match(/([0-9]+)/g)\n  .slice(0, 2)\n  .map(function (v) { return zeroFill(2, v) })\n  .join('')\n\n/**\n * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style\n * encoding: '-', two characters for client id ('WW'), four ascii digits for version\n * number, '-', followed by random numbers.\n * For example:\n *   '-WW0102-'...\n */\nvar VERSION_PREFIX = '-WW' + VERSION_STR + '-'\n\ninherits(WebTorrent, EventEmitter)\n\n/**\n * WebTorrent Client\n * @param {Object=} opts\n */\nfunction WebTorrent (opts) {\n  var self = this\n  if (!(self instanceof WebTorrent)) return new WebTorrent(opts)\n  EventEmitter.call(self)\n\n  if (!opts) opts = {}\n\n  if (typeof opts.peerId === 'string') {\n    self.peerId = opts.peerId\n  } else if (Buffer.isBuffer(opts.peerId)) {\n    self.peerId = opts.peerId.toString('hex')\n  } else {\n    self.peerId = Buffer.from(VERSION_PREFIX + randombytes(9).toString('base64')).toString('hex')\n  }\n  self.peerIdBuffer = Buffer.from(self.peerId, 'hex')\n\n  if (typeof opts.nodeId === 'string') {\n    self.nodeId = opts.nodeId\n  } else if (Buffer.isBuffer(opts.nodeId)) {\n    self.nodeId = opts.nodeId.toString('hex')\n  } else {\n    self.nodeId = randombytes(20).toString('hex')\n  }\n  self.nodeIdBuffer = Buffer.from(self.nodeId, 'hex')\n\n  self._debugId = self.peerId.toString('hex').substring(0, 7)\n\n  self.destroyed = false\n  self.listening = false\n  self.torrentPort = opts.torrentPort || 0\n  self.dhtPort = opts.dhtPort || 0\n  self.tracker = opts.tracker !== undefined ? opts.tracker : {}\n  self.torrents = []\n  self.maxConns = Number(opts.maxConns) || 55\n\n  self._debug(\n    'new webtorrent (peerId %s, nodeId %s, port %s)',\n    self.peerId, self.nodeId, self.torrentPort\n  )\n\n  if (self.tracker) {\n    if (typeof self.tracker !== 'object') self.tracker = {}\n    if (opts.rtcConfig) {\n      // TODO: remove in v1\n      console.warn('WebTorrent: opts.rtcConfig is deprecated. Use opts.tracker.rtcConfig instead')\n      self.tracker.rtcConfig = opts.rtcConfig\n    }\n    if (opts.wrtc) {\n      // TODO: remove in v1\n      console.warn('WebTorrent: opts.wrtc is deprecated. Use opts.tracker.wrtc instead')\n      self.tracker.wrtc = opts.wrtc\n    }\n    if (global.WRTC && !self.tracker.wrtc) {\n      self.tracker.wrtc = global.WRTC\n    }\n  }\n\n  if (typeof TCPPool === 'function') {\n    self._tcpPool = new TCPPool(self)\n  } else {\n    process.nextTick(function () {\n      self._onListening()\n    })\n  }\n\n  // stats\n  self._downloadSpeed = speedometer()\n  self._uploadSpeed = speedometer()\n\n  if (opts.dht !== false && typeof DHT === 'function' /* browser exclude */) {\n    // use a single DHT instance for all torrents, so the routing table can be reused\n    self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))\n\n    self.dht.once('error', function (err) {\n      self._destroy(err)\n    })\n\n    self.dht.once('listening', function () {\n      var address = self.dht.address()\n      if (address) self.dhtPort = address.port\n    })\n\n    // Ignore warning when there are > 10 torrents in the client\n    self.dht.setMaxListeners(0)\n\n    self.dht.listen(self.dhtPort)\n  } else {\n    self.dht = false\n  }\n\n  // Enable or disable BEP19 (Web Seeds). Enabled by default:\n  self.enableWebSeeds = opts.webSeeds !== false\n\n  if (typeof loadIPSet === 'function' && opts.blocklist != null) {\n    loadIPSet(opts.blocklist, {\n      headers: {\n        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'\n      }\n    }, function (err, ipSet) {\n      if (err) return self.error('Failed to load blocklist: ' + err.message)\n      self.blocked = ipSet\n      ready()\n    })\n  } else {\n    process.nextTick(ready)\n  }\n\n  function ready () {\n    if (self.destroyed) return\n    self.ready = true\n    self.emit('ready')\n  }\n}\n\nWebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT\n\nObject.defineProperty(WebTorrent.prototype, 'downloadSpeed', {\n  get: function () { return this._downloadSpeed() }\n})\n\nObject.defineProperty(WebTorrent.prototype, 'uploadSpeed', {\n  get: function () { return this._uploadSpeed() }\n})\n\nObject.defineProperty(WebTorrent.prototype, 'progress', {\n  get: function () {\n    var torrents = this.torrents.filter(function (torrent) {\n      return torrent.progress !== 1\n    })\n    var downloaded = torrents.reduce(function (total, torrent) {\n      return total + torrent.downloaded\n    }, 0)\n    var length = torrents.reduce(function (total, torrent) {\n      return total + (torrent.length || 0)\n    }, 0) || 1\n    return downloaded / length\n  }\n})\n\nObject.defineProperty(WebTorrent.prototype, 'ratio', {\n  get: function () {\n    var uploaded = this.torrents.reduce(function (total, torrent) {\n      return total + torrent.uploaded\n    }, 0)\n    var received = this.torrents.reduce(function (total, torrent) {\n      return total + torrent.received\n    }, 0) || 1\n    return uploaded / received\n  }\n})\n\n/**\n * Returns the torrent with the given `torrentId`. Convenience method. Easier than\n * searching through the `client.torrents` array. Returns `null` if no matching torrent\n * found.\n *\n * @param  {string|Buffer|Object|Torrent} torrentId\n * @return {Torrent|null}\n */\nWebTorrent.prototype.get = function (torrentId) {\n  var self = this\n  var i, torrent\n  var len = self.torrents.length\n\n  if (torrentId instanceof Torrent) {\n    for (i = 0; i < len; i++) {\n      torrent = self.torrents[i]\n      if (torrent === torrentId) return torrent\n    }\n  } else {\n    var parsed\n    try { parsed = parseTorrent(torrentId) } catch (err) {}\n\n    if (!parsed) return null\n    if (!parsed.infoHash) throw new Error('Invalid torrent identifier')\n\n    for (i = 0; i < len; i++) {\n      torrent = self.torrents[i]\n      if (torrent.infoHash === parsed.infoHash) return torrent\n    }\n  }\n  return null\n}\n\n// TODO: remove in v1\nWebTorrent.prototype.download = function (torrentId, opts, ontorrent) {\n  console.warn('WebTorrent: client.download() is deprecated. Use client.add() instead')\n  return this.add(torrentId, opts, ontorrent)\n}\n\n/**\n * Start downloading a new torrent. Aliased as `client.download`.\n * @param {string|Buffer|Object} torrentId\n * @param {Object} opts torrent-specific options\n * @param {function=} ontorrent called when the torrent is ready (has metadata)\n */\nWebTorrent.prototype.add = function (torrentId, opts, ontorrent) {\n  var self = this\n  if (self.destroyed) throw new Error('client is destroyed')\n  if (typeof opts === 'function') return self.add(torrentId, null, opts)\n\n  self._debug('add')\n  opts = opts ? extend(opts) : {}\n\n  var torrent = new Torrent(torrentId, self, opts)\n  self.torrents.push(torrent)\n\n  torrent.once('_infoHash', onInfoHash)\n  torrent.once('ready', onReady)\n  torrent.once('close', onClose)\n\n  function onInfoHash () {\n    if (self.destroyed) return\n    for (var i = 0, len = self.torrents.length; i < len; i++) {\n      var t = self.torrents[i]\n      if (t.infoHash === torrent.infoHash && t !== torrent) {\n        torrent._destroy(new Error('Cannot add duplicate torrent ' + torrent.infoHash))\n        return\n      }\n    }\n  }\n\n  function onReady () {\n    if (self.destroyed) return\n    if (typeof ontorrent === 'function') ontorrent(torrent)\n    self.emit('torrent', torrent)\n  }\n\n  function onClose () {\n    torrent.removeListener('_infoHash', onInfoHash)\n    torrent.removeListener('ready', onReady)\n    torrent.removeListener('close', onClose)\n  }\n\n  return torrent\n}\n\n/**\n * Start seeding a new file/folder.\n * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input\n * @param  {Object=} opts\n * @param  {function=} onseed called when torrent is seeding\n */\nWebTorrent.prototype.seed = function (input, opts, onseed) {\n  var self = this\n  if (self.destroyed) throw new Error('client is destroyed')\n  if (typeof opts === 'function') return self.seed(input, null, opts)\n\n  self._debug('seed')\n  opts = opts ? extend(opts) : {}\n\n  // When seeding from fs path, initialize store from that path to avoid a copy\n  if (typeof input === 'string') opts.path = path.dirname(input)\n  if (!opts.createdBy) opts.createdBy = 'WebTorrent/' + VERSION_STR\n\n  var torrent = self.add(null, opts, onTorrent)\n  var streams\n\n  if (isFileList(input)) input = Array.prototype.slice.call(input)\n  if (!Array.isArray(input)) input = [ input ]\n\n  parallel(input.map(function (item) {\n    return function (cb) {\n      if (isReadable(item)) concat(item, cb)\n      else cb(null, item)\n    }\n  }), function (err, input) {\n    if (self.destroyed) return\n    if (err) return torrent._destroy(err)\n\n    createTorrent.parseInput(input, opts, function (err, files) {\n      if (self.destroyed) return\n      if (err) return torrent._destroy(err)\n\n      streams = files.map(function (file) {\n        return file.getStream\n      })\n\n      createTorrent(input, opts, function (err, torrentBuf) {\n        if (self.destroyed) return\n        if (err) return torrent._destroy(err)\n\n        var existingTorrent = self.get(torrentBuf)\n        if (existingTorrent) {\n          torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))\n        } else {\n          torrent._onTorrentId(torrentBuf)\n        }\n      })\n    })\n  })\n\n  function onTorrent (torrent) {\n    var tasks = [\n      function (cb) {\n        torrent.load(streams, cb)\n      }\n    ]\n    if (self.dht) {\n      tasks.push(function (cb) {\n        torrent.once('dhtAnnounce', cb)\n      })\n    }\n    parallel(tasks, function (err) {\n      if (self.destroyed) return\n      if (err) return torrent._destroy(err)\n      _onseed(torrent)\n    })\n  }\n\n  function _onseed (torrent) {\n    self._debug('on seed')\n    if (typeof onseed === 'function') onseed(torrent)\n    torrent.emit('seed')\n    self.emit('seed', torrent)\n  }\n\n  return torrent\n}\n\n/**\n * Remove a torrent from the client.\n * @param  {string|Buffer|Torrent}   torrentId\n * @param  {function} cb\n */\nWebTorrent.prototype.remove = function (torrentId, cb) {\n  this._debug('remove')\n  var torrent = this.get(torrentId)\n  if (!torrent) throw new Error('No torrent with id ' + torrentId)\n  this._remove(torrentId, cb)\n}\n\nWebTorrent.prototype._remove = function (torrentId, cb) {\n  var torrent = this.get(torrentId)\n  if (!torrent) return\n  this.torrents.splice(this.torrents.indexOf(torrent), 1)\n  torrent.destroy(cb)\n}\n\nWebTorrent.prototype.address = function () {\n  if (!this.listening) return null\n  return this._tcpPool\n    ? this._tcpPool.server.address()\n    : { address: '0.0.0.0', family: 'IPv4', port: 0 }\n}\n\n/**\n * Destroy the client, including all torrents and connections to peers.\n * @param  {function} cb\n */\nWebTorrent.prototype.destroy = function (cb) {\n  if (this.destroyed) throw new Error('client already destroyed')\n  this._destroy(null, cb)\n}\n\nWebTorrent.prototype._destroy = function (err, cb) {\n  var self = this\n  self._debug('client destroy')\n  self.destroyed = true\n\n  var tasks = self.torrents.map(function (torrent) {\n    return function (cb) {\n      torrent.destroy(cb)\n    }\n  })\n\n  if (self._tcpPool) {\n    tasks.push(function (cb) {\n      self._tcpPool.destroy(cb)\n    })\n  }\n\n  if (self.dht) {\n    tasks.push(function (cb) {\n      self.dht.destroy(cb)\n    })\n  }\n\n  parallel(tasks, cb)\n\n  if (err) self.emit('error', err)\n\n  self.torrents = []\n  self._tcpPool = null\n  self.dht = null\n}\n\nWebTorrent.prototype._onListening = function () {\n  this._debug('listening')\n  this.listening = true\n\n  if (this._tcpPool) {\n    // Sometimes server.address() returns `null` in Docker.\n    var address = this._tcpPool.server.address()\n    if (address) this.torrentPort = address.port\n  }\n\n  this.emit('listening')\n}\n\nWebTorrent.prototype._debug = function () {\n  var args = [].slice.call(arguments)\n  args[0] = '[' + this._debugId + '] ' + args[0]\n  debug.apply(null, args)\n}\n\n/**\n * Check if `obj` is a node Readable stream\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isReadable (obj) {\n  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'\n}\n\n/**\n * Check if `obj` is a W3C `FileList` object\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isFileList (obj) {\n  return typeof FileList !== 'undefined' && obj instanceof FileList\n}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/tcp-pool.js":"module.exports = TCPPool\n\nvar arrayRemove = require('unordered-array-remove')\nvar debug = require('debug')('webtorrent:tcp-pool')\nvar net = require('net') // browser exclude\n\nvar Peer = require('./peer')\n\n/**\n * TCPPool\n *\n * A \"TCP pool\" allows multiple swarms to listen on the same TCP port and determines\n * which swarm incoming connections are intended for by inspecting the bittorrent\n * handshake that the remote peer sends.\n *\n * @param {number} port\n */\nfunction TCPPool (client) {\n  var self = this\n  debug('create tcp pool (port %s)', client.torrentPort)\n\n  self.server = net.createServer()\n  self._client = client\n\n  // Temporarily store incoming connections so they can be destroyed if the server is\n  // closed before the connection is passed off to a Torrent.\n  self._pendingConns = []\n\n  self._onConnectionBound = function (conn) {\n    self._onConnection(conn)\n  }\n\n  self._onListening = function () {\n    self._client._onListening()\n  }\n\n  self._onError = function (err) {\n    self._client._destroy(err)\n  }\n\n  self.server.on('connection', self._onConnectionBound)\n  self.server.on('listening', self._onListening)\n  self.server.on('error', self._onError)\n\n  self.server.listen(client.torrentPort)\n}\n\n/**\n * Destroy this TCP pool.\n * @param  {function} cb\n */\nTCPPool.prototype.destroy = function (cb) {\n  var self = this\n  debug('destroy tcp pool')\n\n  self.server.removeListener('connection', self._onConnectionBound)\n  self.server.removeListener('listening', self._onListening)\n  self.server.removeListener('error', self._onError)\n\n  // Destroy all open connection objects so server can close gracefully without waiting\n  // for connection timeout or remote peer to disconnect.\n  self._pendingConns.forEach(function (conn) {\n    conn.on('error', noop)\n    conn.destroy()\n  })\n\n  try {\n    self.server.close(cb)\n  } catch (err) {\n    if (cb) process.nextTick(cb)\n  }\n\n  self.server = null\n  self._client = null\n  self._pendingConns = null\n}\n\n/**\n * On incoming connections, we expect the remote peer to send a handshake first. Based\n * on the infoHash in that handshake, route the peer to the right swarm.\n */\nTCPPool.prototype._onConnection = function (conn) {\n  var self = this\n\n  // If the connection has already been closed before the `connect` event is fired,\n  // then `remoteAddress` will not be available, and we can't use this connection.\n  // - Node.js issue: https://github.com/nodejs/node-v0.x-archive/issues/7566\n  // - WebTorrent issue: https://github.com/webtorrent/webtorrent/issues/398\n  if (!conn.remoteAddress) {\n    conn.on('error', noop)\n    conn.destroy()\n    return\n  }\n\n  self._pendingConns.push(conn)\n  conn.once('close', cleanupPending)\n\n  var peer = Peer.createTCPIncomingPeer(conn)\n\n  var wire = peer.wire\n  wire.once('handshake', onHandshake)\n\n  function onHandshake (infoHash, peerId) {\n    cleanupPending()\n\n    var torrent = self._client.get(infoHash)\n    if (torrent) {\n      peer.swarm = torrent\n      torrent._addIncomingPeer(peer)\n      peer.onHandshake(infoHash, peerId)\n    } else {\n      var err = new Error(\n        'Unexpected info hash ' + infoHash + ' from incoming peer ' + peer.id\n      )\n      peer.destroy(err)\n    }\n  }\n\n  function cleanupPending () {\n    conn.removeListener('close', cleanupPending)\n    wire.removeListener('handshake', onHandshake)\n    if (self._pendingConns) {\n      arrayRemove(self._pendingConns, self._pendingConns.indexOf(conn))\n    }\n  }\n}\n\nfunction noop () {}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/peer.js":"var arrayRemove = require('unordered-array-remove')\nvar debug = require('debug')('webtorrent:peer')\nvar Wire = require('bittorrent-protocol')\n\nvar WebConn = require('./webconn')\n\nvar CONNECT_TIMEOUT_TCP = 5000\nvar CONNECT_TIMEOUT_WEBRTC = 25000\nvar HANDSHAKE_TIMEOUT = 25000\n\n/**\n * WebRTC peer connections start out connected, because WebRTC peers require an\n * \"introduction\" (i.e. WebRTC signaling), and there's no equivalent to an IP address\n * that lets you refer to a WebRTC endpoint.\n */\nexports.createWebRTCPeer = function (conn, swarm) {\n  var peer = new Peer(conn.id, 'webrtc')\n  peer.conn = conn\n  peer.swarm = swarm\n\n  if (peer.conn.connected) {\n    peer.onConnect()\n  } else {\n    peer.conn.once('connect', function () { peer.onConnect() })\n    peer.conn.once('error', function (err) { peer.destroy(err) })\n    peer.startConnectTimeout()\n  }\n\n  return peer\n}\n\n/**\n * Incoming TCP peers start out connected, because the remote peer connected to the\n * listening port of the TCP server. Until the remote peer sends a handshake, we don't\n * know what swarm the connection is intended for.\n */\nexports.createTCPIncomingPeer = function (conn) {\n  var addr = conn.remoteAddress + ':' + conn.remotePort\n  var peer = new Peer(addr, 'tcpIncoming')\n  peer.conn = conn\n  peer.addr = addr\n\n  peer.onConnect()\n\n  return peer\n}\n\n/**\n * Outgoing TCP peers start out with just an IP address. At some point (when there is an\n * available connection), the client can attempt to connect to the address.\n */\nexports.createTCPOutgoingPeer = function (addr, swarm) {\n  var peer = new Peer(addr, 'tcpOutgoing')\n  peer.addr = addr\n  peer.swarm = swarm\n\n  return peer\n}\n\n/**\n * Peer that represents a Web Seed (BEP17 / BEP19).\n */\nexports.createWebSeedPeer = function (url, swarm) {\n  var peer = new Peer(url, 'webSeed')\n  peer.swarm = swarm\n  peer.conn = new WebConn(url, swarm)\n\n  peer.onConnect()\n\n  return peer\n}\n\n/**\n * Peer. Represents a peer in the torrent swarm.\n *\n * @param {string} id \"ip:port\" string, peer id (for WebRTC peers), or url (for Web Seeds)\n * @param {string} type the type of the peer\n */\nfunction Peer (id, type) {\n  var self = this\n  self.id = id\n  self.type = type\n\n  debug('new Peer %s', id)\n\n  self.addr = null\n  self.conn = null\n  self.swarm = null\n  self.wire = null\n\n  self.connected = false\n  self.destroyed = false\n  self.timeout = null // handshake timeout\n  self.retries = 0 // outgoing TCP connection retry count\n\n  self.sentHandshake = false\n}\n\n/**\n * Called once the peer is connected (i.e. fired 'connect' event)\n * @param {Socket} conn\n */\nPeer.prototype.onConnect = function () {\n  var self = this\n  if (self.destroyed) return\n  self.connected = true\n\n  debug('Peer %s connected', self.id)\n\n  clearTimeout(self.connectTimeout)\n\n  var conn = self.conn\n  conn.once('end', function () {\n    self.destroy()\n  })\n  conn.once('close', function () {\n    self.destroy()\n  })\n  conn.once('finish', function () {\n    self.destroy()\n  })\n  conn.once('error', function (err) {\n    self.destroy(err)\n  })\n\n  var wire = self.wire = new Wire()\n  wire.type = self.type\n  wire.once('end', function () {\n    self.destroy()\n  })\n  wire.once('close', function () {\n    self.destroy()\n  })\n  wire.once('finish', function () {\n    self.destroy()\n  })\n  wire.once('error', function (err) {\n    self.destroy(err)\n  })\n\n  wire.once('handshake', function (infoHash, peerId) {\n    self.onHandshake(infoHash, peerId)\n  })\n  self.startHandshakeTimeout()\n\n  conn.pipe(wire).pipe(conn)\n  if (self.swarm && !self.sentHandshake) self.handshake()\n}\n\n/**\n * Called when handshake is received from remote peer.\n * @param {string} infoHash\n * @param {string} peerId\n */\nPeer.prototype.onHandshake = function (infoHash, peerId) {\n  var self = this\n  if (!self.swarm) return // `self.swarm` not set yet, so do nothing\n  if (self.destroyed) return\n\n  if (self.swarm.destroyed) {\n    return self.destroy(new Error('swarm already destroyed'))\n  }\n  if (infoHash !== self.swarm.infoHash) {\n    return self.destroy(new Error('unexpected handshake info hash for this swarm'))\n  }\n  if (peerId === self.swarm.peerId) {\n    return self.destroy(new Error('refusing to connect to ourselves'))\n  }\n\n  debug('Peer %s got handshake %s', self.id, infoHash)\n\n  clearTimeout(self.handshakeTimeout)\n\n  self.retries = 0\n\n  var addr = self.addr\n  if (!addr && self.conn.remoteAddress) {\n    addr = self.conn.remoteAddress + ':' + self.conn.remotePort\n  }\n  self.swarm._onWire(self.wire, addr)\n\n  // swarm could be destroyed in user's 'wire' event handler\n  if (!self.swarm || self.swarm.destroyed) return\n\n  if (!self.sentHandshake) self.handshake()\n}\n\nPeer.prototype.handshake = function () {\n  var self = this\n  var opts = {\n    dht: self.swarm.private ? false : !!self.swarm.client.dht\n  }\n  self.wire.handshake(self.swarm.infoHash, self.swarm.client.peerId, opts)\n  self.sentHandshake = true\n}\n\nPeer.prototype.startConnectTimeout = function () {\n  var self = this\n  clearTimeout(self.connectTimeout)\n  self.connectTimeout = setTimeout(function () {\n    self.destroy(new Error('connect timeout'))\n  }, self.type === 'webrtc' ? CONNECT_TIMEOUT_WEBRTC : CONNECT_TIMEOUT_TCP)\n  if (self.connectTimeout.unref) self.connectTimeout.unref()\n}\n\nPeer.prototype.startHandshakeTimeout = function () {\n  var self = this\n  clearTimeout(self.handshakeTimeout)\n  self.handshakeTimeout = setTimeout(function () {\n    self.destroy(new Error('handshake timeout'))\n  }, HANDSHAKE_TIMEOUT)\n  if (self.handshakeTimeout.unref) self.handshakeTimeout.unref()\n}\n\nPeer.prototype.destroy = function (err) {\n  var self = this\n  if (self.destroyed) return\n  self.destroyed = true\n  self.connected = false\n\n  debug('destroy %s (error: %s)', self.id, err && (err.message || err))\n\n  clearTimeout(self.connectTimeout)\n  clearTimeout(self.handshakeTimeout)\n\n  var swarm = self.swarm\n  var conn = self.conn\n  var wire = self.wire\n\n  self.swarm = null\n  self.conn = null\n  self.wire = null\n\n  if (swarm && wire) {\n    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))\n  }\n  if (conn) {\n    conn.on('error', noop)\n    conn.destroy()\n  }\n  if (wire) wire.destroy()\n  if (swarm) swarm.removePeer(self.id)\n}\n\nfunction noop () {}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/webconn.js":"module.exports = WebConn\n\nvar BitField = require('bitfield')\nvar Buffer = require('safe-buffer').Buffer\nvar debug = require('debug')('webtorrent:webconn')\nvar get = require('simple-get')\nvar inherits = require('inherits')\nvar sha1 = require('simple-sha1')\nvar Wire = require('bittorrent-protocol')\n\nvar VERSION = require('../package.json').version\n\ninherits(WebConn, Wire)\n\n/**\n * Converts requests for torrent blocks into http range requests.\n * @param {string} url web seed url\n * @param {Object} torrent\n */\nfunction WebConn (url, torrent) {\n  Wire.call(this)\n\n  this.url = url\n  this.webPeerId = sha1.sync(url)\n  this._torrent = torrent\n\n  this._init()\n}\n\nWebConn.prototype._init = function () {\n  var self = this\n  self.setKeepAlive(true)\n\n  self.once('handshake', function (infoHash, peerId) {\n    if (self.destroyed) return\n    self.handshake(infoHash, self.webPeerId)\n    var numPieces = self._torrent.pieces.length\n    var bitfield = new BitField(numPieces)\n    for (var i = 0; i <= numPieces; i++) {\n      bitfield.set(i, true)\n    }\n    self.bitfield(bitfield)\n  })\n\n  self.once('interested', function () {\n    debug('interested')\n    self.unchoke()\n  })\n\n  self.on('uninterested', function () { debug('uninterested') })\n  self.on('choke', function () { debug('choke') })\n  self.on('unchoke', function () { debug('unchoke') })\n  self.on('bitfield', function () { debug('bitfield') })\n\n  self.on('request', function (pieceIndex, offset, length, callback) {\n    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)\n    self.httpRequest(pieceIndex, offset, length, callback)\n  })\n}\n\nWebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {\n  var self = this\n  var pieceOffset = pieceIndex * self._torrent.pieceLength\n  var rangeStart = pieceOffset + offset /* offset within whole torrent */\n  var rangeEnd = rangeStart + length - 1\n\n  // Web seed URL format:\n  // For single-file torrents, make HTTP range requests directly to the web seed URL\n  // For multi-file torrents, add the torrent folder and file name to the URL\n  var files = self._torrent.files\n  var requests\n  if (files.length <= 1) {\n    requests = [{\n      url: self.url,\n      start: rangeStart,\n      end: rangeEnd\n    }]\n  } else {\n    var requestedFiles = files.filter(function (file) {\n      return file.offset <= rangeEnd && (file.offset + file.length) > rangeStart\n    })\n    if (requestedFiles.length < 1) {\n      return cb(new Error('Could not find file corresponnding to web seed range request'))\n    }\n\n    requests = requestedFiles.map(function (requestedFile) {\n      var fileEnd = requestedFile.offset + requestedFile.length - 1\n      var url = self.url +\n        (self.url[self.url.length - 1] === '/' ? '' : '/') +\n        requestedFile.path\n      return {\n        url: url,\n        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),\n        start: Math.max(rangeStart - requestedFile.offset, 0),\n        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)\n      }\n    })\n  }\n\n  // Now make all the HTTP requests we need in order to load this piece\n  // Usually that's one requests, but sometimes it will be multiple\n  // Send requests in parallel and wait for them all to come back\n  var numRequestsSucceeded = 0\n  var hasError = false\n\n  var ret\n  if (requests.length > 1) {\n    ret = Buffer.alloc(length)\n  }\n\n  requests.forEach(function (request) {\n    var url = request.url\n    var start = request.start\n    var end = request.end\n    debug(\n      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',\n      url, pieceIndex, offset, length, start, end\n    )\n    var opts = {\n      url: url,\n      method: 'GET',\n      headers: {\n        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)',\n        range: 'bytes=' + start + '-' + end\n      }\n    }\n    function onResponse (res, data) {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        hasError = true\n        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))\n      }\n      debug('Got data of length %d', data.length)\n\n      if (requests.length === 1) {\n        // Common case: fetch piece in a single HTTP request, return directly\n        cb(null, data)\n      } else {\n        // Rare case: reconstruct multiple HTTP requests across 2+ files into one\n        // piece buffer\n        data.copy(ret, request.fileOffsetInRange)\n        if (++numRequestsSucceeded === requests.length) {\n          cb(null, ret)\n        }\n      }\n    }\n    get.concat(opts, function (err, res, data) {\n      if (hasError) return\n      if (err) {\n        // Browsers allow HTTP redirects for simple cross-origin\n        // requests but not for requests that require preflight.\n        // Use a simple request to unravel any redirects and get the\n        // final URL.  Retry the original request with the new URL if\n        // it's different.\n        //\n        // This test is imperfect but it's simple and good for common\n        // cases.  It catches all cross-origin cases but matches a few\n        // same-origin cases too.\n        if (typeof window === 'undefined' || url.startsWith(window.location.origin + '/')) {\n          hasError = true\n          return cb(err)\n        }\n\n        return get.head(url, function (errHead, res) {\n          if (hasError) return\n          if (errHead) {\n            hasError = true\n            return cb(errHead)\n          }\n          if (res.statusCode < 200 || res.statusCode >= 300) {\n            hasError = true\n            return cb(new Error('Unexpected HTTP status code ' + res.statusCode))\n          }\n          if (res.url === url) {\n            hasError = true\n            return cb(err)\n          }\n\n          opts.url = res.url\n          get.concat(opts, function (err, res, data) {\n            if (hasError) return\n            if (err) {\n              hasError = true\n              return cb(err)\n            }\n            onResponse(res, data)\n          })\n        })\n      }\n      onResponse(res, data)\n    })\n  })\n}\n\nWebConn.prototype.destroy = function () {\n  Wire.prototype.destroy.call(this)\n  this._torrent = null\n}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/torrent.js":"/* global URL, Blob */\n\nmodule.exports = Torrent\n\nvar addrToIPPort = require('addr-to-ip-port')\nvar BitField = require('bitfield')\nvar ChunkStoreWriteStream = require('chunk-store-stream/write')\nvar debug = require('debug')('webtorrent:torrent')\nvar Discovery = require('torrent-discovery')\nvar EventEmitter = require('events').EventEmitter\nvar extend = require('xtend')\nvar extendMutable = require('xtend/mutable')\nvar fs = require('fs')\nvar FSChunkStore = require('fs-chunk-store') // browser: `memory-chunk-store`\nvar get = require('simple-get')\nvar ImmediateChunkStore = require('immediate-chunk-store')\nvar inherits = require('inherits')\nvar MultiStream = require('multistream')\nvar net = require('net') // browser exclude\nvar os = require('os') // browser exclude\nvar parallel = require('run-parallel')\nvar parallelLimit = require('run-parallel-limit')\nvar parseTorrent = require('parse-torrent')\nvar path = require('path')\nvar Piece = require('torrent-piece')\nvar pump = require('pump')\nvar randomIterate = require('random-iterate')\nvar sha1 = require('simple-sha1')\nvar speedometer = require('speedometer')\nvar uniq = require('uniq')\nvar utMetadata = require('ut_metadata')\nvar utPex = require('ut_pex') // browser exclude\n\nvar File = require('./file')\nvar Peer = require('./peer')\nvar RarityMap = require('./rarity-map')\nvar Server = require('./server') // browser exclude\n\nvar MAX_BLOCK_LENGTH = 128 * 1024\nvar PIECE_TIMEOUT = 30000\nvar CHOKE_TIMEOUT = 5000\nvar SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH\n\nvar PIPELINE_MIN_DURATION = 0.5\nvar PIPELINE_MAX_DURATION = 1\n\nvar RECHOKE_INTERVAL = 10000 // 10 seconds\nvar RECHOKE_OPTIMISTIC_DURATION = 2 // 30 seconds\n\nvar FILESYSTEM_CONCURRENCY = 2\n\nvar RECONNECT_WAIT = [ 1000, 5000, 15000 ]\n\nvar VERSION = require('../package.json').version\nvar USER_AGENT = 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'\n\nvar TMP\ntry {\n  TMP = path.join(fs.statSync('/tmp') && '/tmp', 'webtorrent')\n} catch (err) {\n  TMP = path.join(typeof os.tmpdir === 'function' ? os.tmpdir() : '/', 'webtorrent')\n}\n\ninherits(Torrent, EventEmitter)\n\nfunction Torrent (torrentId, client, opts) {\n  EventEmitter.call(this)\n\n  this._debugId = 'unknown infohash'\n  this.client = client\n\n  this.announce = opts.announce\n  this.urlList = opts.urlList\n\n  this.path = opts.path\n  this._store = opts.store || FSChunkStore\n  this._getAnnounceOpts = opts.getAnnounceOpts\n\n  this.strategy = opts.strategy || 'sequential'\n\n  this.maxWebConns = opts.maxWebConns || 4\n\n  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)\n    ? 0\n    : (+opts.uploads || 10)\n  this._rechokeOptimisticWire = null\n  this._rechokeOptimisticTime = 0\n  this._rechokeIntervalId = null\n\n  this.ready = false\n  this.destroyed = false\n  this.paused = false\n  this.done = false\n\n  this.metadata = null\n  this.store = null\n  this.files = []\n  this.pieces = []\n\n  this._amInterested = false\n  this._selections = []\n  this._critical = []\n\n  this.wires = [] // open wires (added *after* handshake)\n\n  this._queue = [] // queue of outgoing tcp peers to connect to\n  this._peers = {} // connected peers (addr/peerId -> Peer)\n  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)\n\n  // stats\n  this.received = 0\n  this.uploaded = 0\n  this._downloadSpeed = speedometer()\n  this._uploadSpeed = speedometer()\n\n  // for cleanup\n  this._servers = []\n  this._xsRequests = []\n\n  // TODO: remove this and expose a hook instead\n  // optimization: don't recheck every file if it hasn't changed\n  this._fileModtimes = opts.fileModtimes\n\n  if (torrentId !== null) this._onTorrentId(torrentId)\n\n  this._debug('new torrent')\n}\n\nObject.defineProperty(Torrent.prototype, 'timeRemaining', {\n  get: function () {\n    if (this.done) return 0\n    if (this.downloadSpeed === 0) return Infinity\n    return ((this.length - this.downloaded) / this.downloadSpeed) * 1000\n  }\n})\n\nObject.defineProperty(Torrent.prototype, 'downloaded', {\n  get: function () {\n    if (!this.bitfield) return 0\n    var downloaded = 0\n    for (var index = 0, len = this.pieces.length; index < len; ++index) {\n      if (this.bitfield.get(index)) { // verified data\n        downloaded += (index === len - 1) ? this.lastPieceLength : this.pieceLength\n      } else { // \"in progress\" data\n        var piece = this.pieces[index]\n        downloaded += (piece.length - piece.missing)\n      }\n    }\n    return downloaded\n  }\n})\n\n// TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.\n// Object.defineProperty(Storage.prototype, 'numMissing', {\n//   get: function () {\n//     var self = this\n//     var numMissing = self.pieces.length\n//     for (var index = 0, len = self.pieces.length; index < len; index++) {\n//       numMissing -= self.bitfield.get(index)\n//     }\n//     return numMissing\n//   }\n// })\n\nObject.defineProperty(Torrent.prototype, 'downloadSpeed', {\n  get: function () { return this._downloadSpeed() }\n})\n\nObject.defineProperty(Torrent.prototype, 'uploadSpeed', {\n  get: function () { return this._uploadSpeed() }\n})\n\nObject.defineProperty(Torrent.prototype, 'progress', {\n  get: function () { return this.length ? this.downloaded / this.length : 0 }\n})\n\nObject.defineProperty(Torrent.prototype, 'ratio', {\n  get: function () { return this.uploaded / (this.received || 1) }\n})\n\nObject.defineProperty(Torrent.prototype, 'numPeers', {\n  get: function () { return this.wires.length }\n})\n\nObject.defineProperty(Torrent.prototype, 'torrentFileBlobURL', {\n  get: function () {\n    if (typeof window === 'undefined') throw new Error('browser-only property')\n    if (!this.torrentFile) return null\n    return URL.createObjectURL(\n      new Blob([ this.torrentFile ], { type: 'application/x-bittorrent' })\n    )\n  }\n})\n\nObject.defineProperty(Torrent.prototype, '_numQueued', {\n  get: function () {\n    return this._queue.length + (this._peersLength - this._numConns)\n  }\n})\n\nObject.defineProperty(Torrent.prototype, '_numConns', {\n  get: function () {\n    var self = this\n    var numConns = 0\n    for (var id in self._peers) {\n      if (self._peers[id].connected) numConns += 1\n    }\n    return numConns\n  }\n})\n\n// TODO: remove in v1\nObject.defineProperty(Torrent.prototype, 'swarm', {\n  get: function () {\n    console.warn('WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead.')\n    return this\n  }\n})\n\nTorrent.prototype._onTorrentId = function (torrentId) {\n  var self = this\n  if (self.destroyed) return\n\n  var parsedTorrent\n  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}\n  if (parsedTorrent) {\n    // Attempt to set infoHash property synchronously\n    self.infoHash = parsedTorrent.infoHash\n    self._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7)\n    process.nextTick(function () {\n      if (self.destroyed) return\n      self._onParsedTorrent(parsedTorrent)\n    })\n  } else {\n    // If torrentId failed to parse, it could be in a form that requires an async\n    // operation, i.e. http/https link, filesystem path, or Blob.\n    parseTorrent.remote(torrentId, function (err, parsedTorrent) {\n      if (self.destroyed) return\n      if (err) return self._destroy(err)\n      self._onParsedTorrent(parsedTorrent)\n    })\n  }\n}\n\nTorrent.prototype._onParsedTorrent = function (parsedTorrent) {\n  var self = this\n  if (self.destroyed) return\n\n  self._processParsedTorrent(parsedTorrent)\n\n  if (!self.infoHash) {\n    return self._destroy(new Error('Malformed torrent data: No info hash'))\n  }\n\n  if (!self.path) self.path = path.join(TMP, self.infoHash)\n\n  self._rechokeIntervalId = setInterval(function () {\n    self._rechoke()\n  }, RECHOKE_INTERVAL)\n  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()\n\n  // Private 'infoHash' event allows client.add to check for duplicate torrents and\n  // destroy them before the normal 'infoHash' event is emitted. Prevents user\n  // applications from needing to deal with duplicate 'infoHash' events.\n  self.emit('_infoHash', self.infoHash)\n  if (self.destroyed) return\n\n  self.emit('infoHash', self.infoHash)\n  if (self.destroyed) return // user might destroy torrent in event handler\n\n  if (self.client.listening) {\n    self._onListening()\n  } else {\n    self.client.once('listening', function () {\n      self._onListening()\n    })\n  }\n}\n\nTorrent.prototype._processParsedTorrent = function (parsedTorrent) {\n  this._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7)\n\n  if (this.announce) {\n    // Allow specifying trackers via `opts` parameter\n    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)\n  }\n\n  if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !this.private) {\n    // So `webtorrent-hybrid` can force specific trackers to be used\n    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)\n  }\n\n  if (this.urlList) {\n    // Allow specifying web seeds via `opts` parameter\n    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)\n  }\n\n  uniq(parsedTorrent.announce)\n  uniq(parsedTorrent.urlList)\n\n  extendMutable(this, parsedTorrent)\n\n  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)\n  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)\n}\n\nTorrent.prototype._onListening = function () {\n  var self = this\n  if (self.discovery || self.destroyed) return\n\n  var trackerOpts = self.client.tracker\n  if (trackerOpts) {\n    trackerOpts = extend(self.client.tracker, {\n      getAnnounceOpts: function () {\n        var opts = {\n          uploaded: self.uploaded,\n          downloaded: self.downloaded,\n          left: Math.max(self.length - self.downloaded, 0)\n        }\n        if (self.client.tracker.getAnnounceOpts) {\n          extendMutable(opts, self.client.tracker.getAnnounceOpts())\n        }\n        if (self._getAnnounceOpts) {\n          // TODO: consider deprecating this, as it's redundant with the former case\n          extendMutable(opts, self._getAnnounceOpts())\n        }\n        return opts\n      }\n    })\n  }\n\n  // begin discovering peers via DHT and trackers\n  self.discovery = new Discovery({\n    infoHash: self.infoHash,\n    announce: self.announce,\n    peerId: self.client.peerId,\n    dht: !self.private && self.client.dht,\n    tracker: trackerOpts,\n    port: self.client.torrentPort,\n    userAgent: USER_AGENT\n  })\n\n  self.discovery.on('error', onError)\n  self.discovery.on('peer', onPeer)\n  self.discovery.on('trackerAnnounce', onTrackerAnnounce)\n  self.discovery.on('dhtAnnounce', onDHTAnnounce)\n  self.discovery.on('warning', onWarning)\n\n  function onError (err) {\n    self._destroy(err)\n  }\n\n  function onPeer (peer) {\n    // Don't create new outgoing TCP connections when torrent is done\n    if (typeof peer === 'string' && self.done) return\n    self.addPeer(peer)\n  }\n\n  function onTrackerAnnounce () {\n    self.emit('trackerAnnounce')\n    if (self.numPeers === 0) self.emit('noPeers', 'tracker')\n  }\n\n  function onDHTAnnounce () {\n    self.emit('dhtAnnounce')\n    if (self.numPeers === 0) self.emit('noPeers', 'dht')\n  }\n\n  function onWarning (err) {\n    self.emit('warning', err)\n  }\n\n  if (self.info) {\n    // if full metadata was included in initial torrent id, use it immediately. Otherwise,\n    // wait for torrent-discovery to find peers and ut_metadata to get the metadata.\n    self._onMetadata(self)\n  } else if (self.xs) {\n    self._getMetadataFromServer()\n  }\n}\n\nTorrent.prototype._getMetadataFromServer = function () {\n  var self = this\n  var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]\n\n  var tasks = urls.map(function (url) {\n    return function (cb) {\n      getMetadataFromURL(url, cb)\n    }\n  })\n  parallel(tasks)\n\n  function getMetadataFromURL (url, cb) {\n    if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {\n      self.emit('warning', new Error('skipping non-http xs param: ' + url))\n      return cb(null)\n    }\n\n    var opts = {\n      url: url,\n      method: 'GET',\n      headers: {\n        'user-agent': USER_AGENT\n      }\n    }\n    var req\n    try {\n      req = get.concat(opts, onResponse)\n    } catch (err) {\n      self.emit('warning', new Error('skipping invalid url xs param: ' + url))\n      return cb(null)\n    }\n\n    self._xsRequests.push(req)\n\n    function onResponse (err, res, torrent) {\n      if (self.destroyed) return cb(null)\n      if (self.metadata) return cb(null)\n\n      if (err) {\n        self.emit('warning', new Error('http error from xs param: ' + url))\n        return cb(null)\n      }\n      if (res.statusCode !== 200) {\n        self.emit('warning', new Error('non-200 status code ' + res.statusCode + ' from xs param: ' + url))\n        return cb(null)\n      }\n\n      var parsedTorrent\n      try {\n        parsedTorrent = parseTorrent(torrent)\n      } catch (err) {}\n\n      if (!parsedTorrent) {\n        self.emit('warning', new Error('got invalid torrent file from xs param: ' + url))\n        return cb(null)\n      }\n\n      if (parsedTorrent.infoHash !== self.infoHash) {\n        self.emit('warning', new Error('got torrent file with incorrect info hash from xs param: ' + url))\n        return cb(null)\n      }\n\n      self._onMetadata(parsedTorrent)\n      cb(null)\n    }\n  }\n}\n\n/**\n * Called when the full torrent metadata is received.\n */\nTorrent.prototype._onMetadata = function (metadata) {\n  var self = this\n  if (self.metadata || self.destroyed) return\n  self._debug('got metadata')\n\n  self._xsRequests.forEach(function (req) {\n    req.abort()\n  })\n  self._xsRequests = []\n\n  var parsedTorrent\n  if (metadata && metadata.infoHash) {\n    // `metadata` is a parsed torrent (from parse-torrent module)\n    parsedTorrent = metadata\n  } else {\n    try {\n      parsedTorrent = parseTorrent(metadata)\n    } catch (err) {\n      return self._destroy(err)\n    }\n  }\n\n  self._processParsedTorrent(parsedTorrent)\n  self.metadata = self.torrentFile\n\n  // add web seed urls (BEP19)\n  if (self.client.enableWebSeeds) {\n    self.urlList.forEach(function (url) {\n      self.addWebSeed(url)\n    })\n  }\n\n  // start off selecting the entire torrent with low priority\n  if (self.pieces.length !== 0) {\n    self.select(0, self.pieces.length - 1, false)\n  }\n\n  self._rarityMap = new RarityMap(self)\n\n  self.store = new ImmediateChunkStore(\n    new self._store(self.pieceLength, {\n      torrent: {\n        infoHash: self.infoHash\n      },\n      files: self.files.map(function (file) {\n        return {\n          path: path.join(self.path, file.path),\n          length: file.length,\n          offset: file.offset\n        }\n      }),\n      length: self.length\n    })\n  )\n\n  self.files = self.files.map(function (file) {\n    return new File(self, file)\n  })\n\n  self._hashes = self.pieces\n\n  self.pieces = self.pieces.map(function (hash, i) {\n    var pieceLength = (i === self.pieces.length - 1)\n      ? self.lastPieceLength\n      : self.pieceLength\n    return new Piece(pieceLength)\n  })\n\n  self._reservations = self.pieces.map(function () {\n    return []\n  })\n\n  self.bitfield = new BitField(self.pieces.length)\n\n  self.wires.forEach(function (wire) {\n    // If we didn't have the metadata at the time ut_metadata was initialized for this\n    // wire, we still want to make it available to the peer in case they request it.\n    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)\n\n    self._onWireWithMetadata(wire)\n  })\n\n  self._debug('verifying existing torrent data')\n  if (self._fileModtimes && self._store === FSChunkStore) {\n    // don't verify if the files haven't been modified since we last checked\n    self.getFileModtimes(function (err, fileModtimes) {\n      if (err) return self._destroy(err)\n\n      var unchanged = self.files.map(function (_, index) {\n        return fileModtimes[index] === self._fileModtimes[index]\n      }).every(function (x) {\n        return x\n      })\n\n      if (unchanged) {\n        for (var index = 0; index < self.pieces.length; index++) {\n          self._markVerified(index)\n        }\n        self._onStore()\n      } else {\n        self._verifyPieces()\n      }\n    })\n  } else {\n    self._verifyPieces()\n  }\n\n  self.emit('metadata')\n}\n\n/*\n * TODO: remove this\n * Gets the last modified time of every file on disk for this torrent.\n * Only valid in Node, not in the browser.\n */\nTorrent.prototype.getFileModtimes = function (cb) {\n  var self = this\n  var ret = []\n  parallelLimit(self.files.map(function (file, index) {\n    return function (cb) {\n      fs.stat(path.join(self.path, file.path), function (err, stat) {\n        if (err && err.code !== 'ENOENT') return cb(err)\n        ret[index] = stat && stat.mtime.getTime()\n        cb(null)\n      })\n    }\n  }), FILESYSTEM_CONCURRENCY, function (err) {\n    self._debug('done getting file modtimes')\n    cb(err, ret)\n  })\n}\n\nTorrent.prototype._verifyPieces = function () {\n  var self = this\n  parallelLimit(self.pieces.map(function (_, index) {\n    return function (cb) {\n      if (self.destroyed) return cb(new Error('torrent is destroyed'))\n\n      self.store.get(index, function (err, buf) {\n        if (self.destroyed) return cb(new Error('torrent is destroyed'))\n\n        if (err) return process.nextTick(cb, null) // ignore error\n        sha1(buf, function (hash) {\n          if (self.destroyed) return cb(new Error('torrent is destroyed'))\n\n          if (hash === self._hashes[index]) {\n            if (!self.pieces[index]) return\n            self._debug('piece verified %s', index)\n            self._markVerified(index)\n          } else {\n            self._debug('piece invalid %s', index)\n          }\n          cb(null)\n        })\n      })\n    }\n  }), FILESYSTEM_CONCURRENCY, function (err) {\n    if (err) return self._destroy(err)\n    self._debug('done verifying')\n    self._onStore()\n  })\n}\n\nTorrent.prototype._markVerified = function (index) {\n  this.pieces[index] = null\n  this._reservations[index] = null\n  this.bitfield.set(index, true)\n}\n\n/**\n * Called when the metadata, listening server, and underlying chunk store is initialized.\n */\nTorrent.prototype._onStore = function () {\n  var self = this\n  if (self.destroyed) return\n  self._debug('on store')\n\n  self.ready = true\n  self.emit('ready')\n\n  // Files may start out done if the file was already in the store\n  self._checkDone()\n\n  // In case any selections were made before torrent was ready\n  self._updateSelections()\n}\n\nTorrent.prototype.destroy = function (cb) {\n  var self = this\n  self._destroy(null, cb)\n}\n\nTorrent.prototype._destroy = function (err, cb) {\n  var self = this\n  if (self.destroyed) return\n  self.destroyed = true\n  self._debug('destroy')\n\n  self.client._remove(self)\n\n  clearInterval(self._rechokeIntervalId)\n\n  self._xsRequests.forEach(function (req) {\n    req.abort()\n  })\n\n  if (self._rarityMap) {\n    self._rarityMap.destroy()\n  }\n\n  for (var id in self._peers) {\n    self.removePeer(id)\n  }\n\n  self.files.forEach(function (file) {\n    if (file instanceof File) file._destroy()\n  })\n\n  var tasks = self._servers.map(function (server) {\n    return function (cb) {\n      server.destroy(cb)\n    }\n  })\n\n  if (self.discovery) {\n    tasks.push(function (cb) {\n      self.discovery.destroy(cb)\n    })\n  }\n\n  if (self.store) {\n    tasks.push(function (cb) {\n      self.store.close(cb)\n    })\n  }\n\n  parallel(tasks, cb)\n\n  if (err) {\n    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error'\n    // event handlers on the torrent instance, then the error will be emitted at\n    // `client.on('error')`. This prevents throwing an uncaught exception\n    // (unhandled 'error' event), but it makes it impossible to distinguish client\n    // errors versus torrent errors. Torrent errors are not fatal, and the client\n    // is still usable afterwards. Therefore, always listen for errors in both\n    // places (`client.on('error')` and `torrent.on('error')`).\n    if (self.listenerCount('error') === 0) {\n      self.client.emit('error', err)\n    } else {\n      self.emit('error', err)\n    }\n  }\n\n  self.emit('close')\n\n  self.client = null\n  self.files = []\n  self.discovery = null\n  self.store = null\n  self._rarityMap = null\n  self._peers = null\n  self._servers = null\n  self._xsRequests = null\n}\n\nTorrent.prototype.addPeer = function (peer) {\n  var self = this\n  if (self.destroyed) throw new Error('torrent is destroyed')\n  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')\n\n  if (self.client.blocked) {\n    var host\n    if (typeof peer === 'string') {\n      var parts\n      try {\n        parts = addrToIPPort(peer)\n      } catch (e) {\n        self._debug('ignoring peer: invalid %s', peer)\n        self.emit('invalidPeer', peer)\n        return false\n      }\n      host = parts[0]\n    } else if (typeof peer.remoteAddress === 'string') {\n      host = peer.remoteAddress\n    }\n\n    if (host && self.client.blocked.contains(host)) {\n      self._debug('ignoring peer: blocked %s', peer)\n      if (typeof peer !== 'string') peer.destroy()\n      self.emit('blockedPeer', peer)\n      return false\n    }\n  }\n\n  var wasAdded = !!self._addPeer(peer)\n  if (wasAdded) {\n    self.emit('peer', peer)\n  } else {\n    self.emit('invalidPeer', peer)\n  }\n  return wasAdded\n}\n\nTorrent.prototype._addPeer = function (peer) {\n  var self = this\n  if (self.destroyed) {\n    if (typeof peer !== 'string') peer.destroy()\n    return null\n  }\n  if (typeof peer === 'string' && !self._validAddr(peer)) {\n    self._debug('ignoring peer: invalid %s', peer)\n    return null\n  }\n\n  var id = (peer && peer.id) || peer\n  if (self._peers[id]) {\n    self._debug('ignoring peer: duplicate (%s)', id)\n    if (typeof peer !== 'string') peer.destroy()\n    return null\n  }\n\n  if (self.paused) {\n    self._debug('ignoring peer: torrent is paused')\n    if (typeof peer !== 'string') peer.destroy()\n    return null\n  }\n\n  self._debug('add peer %s', id)\n\n  var newPeer\n  if (typeof peer === 'string') {\n    // `peer` is an addr (\"ip:port\" string)\n    newPeer = Peer.createTCPOutgoingPeer(peer, self)\n  } else {\n    // `peer` is a WebRTC connection (simple-peer)\n    newPeer = Peer.createWebRTCPeer(peer, self)\n  }\n\n  self._peers[newPeer.id] = newPeer\n  self._peersLength += 1\n\n  if (typeof peer === 'string') {\n    // `peer` is an addr (\"ip:port\" string)\n    self._queue.push(newPeer)\n    self._drain()\n  }\n\n  return newPeer\n}\n\nTorrent.prototype.addWebSeed = function (url) {\n  if (this.destroyed) throw new Error('torrent is destroyed')\n\n  if (!/^https?:\\/\\/.+/.test(url)) {\n    this.emit('warning', new Error('ignoring invalid web seed: ' + url))\n    this.emit('invalidPeer', url)\n    return\n  }\n\n  if (this._peers[url]) {\n    this.emit('warning', new Error('ignoring duplicate web seed: ' + url))\n    this.emit('invalidPeer', url)\n    return\n  }\n\n  this._debug('add web seed %s', url)\n\n  var newPeer = Peer.createWebSeedPeer(url, this)\n  this._peers[newPeer.id] = newPeer\n  this._peersLength += 1\n\n  this.emit('peer', url)\n}\n\n/**\n * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a\n * peer that has already sent a handshake.\n */\nTorrent.prototype._addIncomingPeer = function (peer) {\n  var self = this\n  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))\n  if (self.paused) return peer.destroy(new Error('torrent is paused'))\n\n  this._debug('add incoming peer %s', peer.id)\n\n  self._peers[peer.id] = peer\n  self._peersLength += 1\n}\n\nTorrent.prototype.removePeer = function (peer) {\n  var self = this\n  var id = (peer && peer.id) || peer\n  peer = self._peers[id]\n\n  if (!peer) return\n\n  this._debug('removePeer %s', id)\n\n  delete self._peers[id]\n  self._peersLength -= 1\n\n  peer.destroy()\n\n  // If torrent swarm was at capacity before, try to open a new connection now\n  self._drain()\n}\n\nTorrent.prototype.select = function (start, end, priority, notify) {\n  var self = this\n  if (self.destroyed) throw new Error('torrent is destroyed')\n\n  if (start < 0 || end < start || self.pieces.length <= end) {\n    throw new Error('invalid selection ', start, ':', end)\n  }\n  priority = Number(priority) || 0\n\n  self._debug('select %s-%s (priority %s)', start, end, priority)\n\n  self._selections.push({\n    from: start,\n    to: end,\n    offset: 0,\n    priority: priority,\n    notify: notify || noop\n  })\n\n  self._selections.sort(function (a, b) {\n    return b.priority - a.priority\n  })\n\n  self._updateSelections()\n}\n\nTorrent.prototype.deselect = function (start, end, priority) {\n  var self = this\n  if (self.destroyed) throw new Error('torrent is destroyed')\n\n  priority = Number(priority) || 0\n  self._debug('deselect %s-%s (priority %s)', start, end, priority)\n\n  for (var i = 0; i < self._selections.length; ++i) {\n    var s = self._selections[i]\n    if (s.from === start && s.to === end && s.priority === priority) {\n      self._selections.splice(i, 1)\n      break\n    }\n  }\n\n  self._updateSelections()\n}\n\nTorrent.prototype.critical = function (start, end) {\n  var self = this\n  if (self.destroyed) throw new Error('torrent is destroyed')\n\n  self._debug('critical %s-%s', start, end)\n\n  for (var i = start; i <= end; ++i) {\n    self._critical[i] = true\n  }\n\n  self._updateSelections()\n}\n\nTorrent.prototype._onWire = function (wire, addr) {\n  var self = this\n  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')\n\n  wire.on('download', function (downloaded) {\n    if (self.destroyed) return\n    self.received += downloaded\n    self._downloadSpeed(downloaded)\n    self.client._downloadSpeed(downloaded)\n    self.emit('download', downloaded)\n    self.client.emit('download', downloaded)\n  })\n\n  wire.on('upload', function (uploaded) {\n    if (self.destroyed) return\n    self.uploaded += uploaded\n    self._uploadSpeed(uploaded)\n    self.client._uploadSpeed(uploaded)\n    self.emit('upload', uploaded)\n    self.client.emit('upload', uploaded)\n  })\n\n  self.wires.push(wire)\n\n  if (addr) {\n    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers\n    var parts = addrToIPPort(addr)\n    wire.remoteAddress = parts[0]\n    wire.remotePort = parts[1]\n  }\n\n  // When peer sends PORT message, add that DHT node to routing table\n  if (self.client.dht && self.client.dht.listening) {\n    wire.on('port', function (port) {\n      if (self.destroyed || self.client.dht.destroyed) {\n        return\n      }\n      if (!wire.remoteAddress) {\n        return self._debug('ignoring PORT from peer with no address')\n      }\n      if (port === 0 || port > 65536) {\n        return self._debug('ignoring invalid PORT from peer')\n      }\n\n      self._debug('port: %s (from %s)', port, addr)\n      self.client.dht.addNode({ host: wire.remoteAddress, port: port })\n    })\n  }\n\n  wire.on('timeout', function () {\n    self._debug('wire timeout (%s)', addr)\n    // TODO: this might be destroying wires too eagerly\n    wire.destroy()\n  })\n\n  // Timeout for piece requests to this peer\n  wire.setTimeout(PIECE_TIMEOUT, true)\n\n  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire\n  wire.setKeepAlive(true)\n\n  // use ut_metadata extension\n  wire.use(utMetadata(self.metadata))\n\n  wire.ut_metadata.on('warning', function (err) {\n    self._debug('ut_metadata warning: %s', err.message)\n  })\n\n  if (!self.metadata) {\n    wire.ut_metadata.on('metadata', function (metadata) {\n      self._debug('got metadata via ut_metadata')\n      self._onMetadata(metadata)\n    })\n    wire.ut_metadata.fetch()\n  }\n\n  // use ut_pex extension if the torrent is not flagged as private\n  if (typeof utPex === 'function' && !self.private) {\n    wire.use(utPex())\n\n    wire.ut_pex.on('peer', function (peer) {\n      // Only add potential new peers when we're not seeding\n      if (self.done) return\n      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)\n      self.addPeer(peer)\n    })\n\n    wire.ut_pex.on('dropped', function (peer) {\n      // the remote peer believes a given peer has been dropped from the torrent swarm.\n      // if we're not currently connected to it, then remove it from the queue.\n      var peerObj = self._peers[peer]\n      if (peerObj && !peerObj.connected) {\n        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)\n        self.removePeer(peer)\n      }\n    })\n\n    wire.once('close', function () {\n      // Stop sending updates to remote peer\n      wire.ut_pex.reset()\n    })\n  }\n\n  // Hook to allow user-defined `bittorrent-protocol` extensions\n  // More info: https://github.com/webtorrent/bittorrent-protocol#extension-api\n  self.emit('wire', wire, addr)\n\n  if (self.metadata) {\n    process.nextTick(function () {\n      // This allows wire.handshake() to be called (by Peer.onHandshake) before any\n      // messages get sent on the wire\n      self._onWireWithMetadata(wire)\n    })\n  }\n}\n\nTorrent.prototype._onWireWithMetadata = function (wire) {\n  var self = this\n  var timeoutId = null\n\n  function onChokeTimeout () {\n    if (self.destroyed || wire.destroyed) return\n\n    if (self._numQueued > 2 * (self._numConns - self.numPeers) &&\n      wire.amInterested) {\n      wire.destroy()\n    } else {\n      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)\n      if (timeoutId.unref) timeoutId.unref()\n    }\n  }\n\n  var i\n  function updateSeedStatus () {\n    if (wire.peerPieces.buffer.length !== self.bitfield.buffer.length) return\n    for (i = 0; i < self.pieces.length; ++i) {\n      if (!wire.peerPieces.get(i)) return\n    }\n    wire.isSeeder = true\n    wire.choke() // always choke seeders\n  }\n\n  wire.on('bitfield', function () {\n    updateSeedStatus()\n    self._update()\n  })\n\n  wire.on('have', function () {\n    updateSeedStatus()\n    self._update()\n  })\n\n  wire.once('interested', function () {\n    wire.unchoke()\n  })\n\n  wire.once('close', function () {\n    clearTimeout(timeoutId)\n  })\n\n  wire.on('choke', function () {\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)\n    if (timeoutId.unref) timeoutId.unref()\n  })\n\n  wire.on('unchoke', function () {\n    clearTimeout(timeoutId)\n    self._update()\n  })\n\n  wire.on('request', function (index, offset, length, cb) {\n    if (length > MAX_BLOCK_LENGTH) {\n      // Per spec, disconnect from peers that request >128KB\n      return wire.destroy()\n    }\n    if (self.pieces[index]) return\n    self.store.get(index, { offset: offset, length: length }, cb)\n  })\n\n  wire.bitfield(self.bitfield) // always send bitfield (required)\n  wire.interested() // always start out interested\n\n  // Send PORT message to peers that support DHT\n  if (wire.peerExtensions.dht && self.client.dht && self.client.dht.listening) {\n    wire.port(self.client.dht.address().port)\n  }\n\n  if (wire.type !== 'webSeed') { // do not choke on webseeds\n    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)\n    if (timeoutId.unref) timeoutId.unref()\n  }\n\n  wire.isSeeder = false\n  updateSeedStatus()\n}\n\n/**\n * Called on selection changes.\n */\nTorrent.prototype._updateSelections = function () {\n  var self = this\n  if (!self.ready || self.destroyed) return\n\n  process.nextTick(function () {\n    self._gcSelections()\n  })\n  self._updateInterest()\n  self._update()\n}\n\n/**\n * Garbage collect selections with respect to the store's current state.\n */\nTorrent.prototype._gcSelections = function () {\n  var self = this\n\n  for (var i = 0; i < self._selections.length; ++i) {\n    var s = self._selections[i]\n    var oldOffset = s.offset\n\n    // check for newly downloaded pieces in selection\n    while (self.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {\n      s.offset += 1\n    }\n\n    if (oldOffset !== s.offset) s.notify()\n    if (s.to !== s.from + s.offset) continue\n    if (!self.bitfield.get(s.from + s.offset)) continue\n\n    self._selections.splice(i, 1) // remove fully downloaded selection\n    i -= 1 // decrement i to offset splice\n\n    s.notify()\n    self._updateInterest()\n  }\n\n  if (!self._selections.length) self.emit('idle')\n}\n\n/**\n * Update interested status for all peers.\n */\nTorrent.prototype._updateInterest = function () {\n  var self = this\n\n  var prev = self._amInterested\n  self._amInterested = !!self._selections.length\n\n  self.wires.forEach(function (wire) {\n    // TODO: only call wire.interested if the wire has at least one piece we need\n    if (self._amInterested) wire.interested()\n    else wire.uninterested()\n  })\n\n  if (prev === self._amInterested) return\n  if (self._amInterested) self.emit('interested')\n  else self.emit('uninterested')\n}\n\n/**\n * Heartbeat to update all peers and their requests.\n */\nTorrent.prototype._update = function () {\n  var self = this\n  if (self.destroyed) return\n\n  // update wires in random order for better request distribution\n  var ite = randomIterate(self.wires)\n  var wire\n  while ((wire = ite())) {\n    self._updateWire(wire)\n  }\n}\n\n/**\n * Attempts to update a peer's requests\n */\nTorrent.prototype._updateWire = function (wire) {\n  var self = this\n\n  if (wire.peerChoking) return\n  if (!wire.downloaded) return validateWire()\n\n  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)\n  if (wire.requests.length >= minOutstandingRequests) return\n  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)\n\n  trySelectWire(false) || trySelectWire(true)\n\n  function genPieceFilterFunc (start, end, tried, rank) {\n    return function (i) {\n      return i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i))\n    }\n  }\n\n  // TODO: Do we need both validateWire and trySelectWire?\n  function validateWire () {\n    if (wire.requests.length) return\n\n    var i = self._selections.length\n    while (i--) {\n      var next = self._selections[i]\n      var piece\n      if (self.strategy === 'rarest') {\n        var start = next.from + next.offset\n        var end = next.to\n        var len = end - start + 1\n        var tried = {}\n        var tries = 0\n        var filter = genPieceFilterFunc(start, end, tried)\n\n        while (tries < len) {\n          piece = self._rarityMap.getRarestPiece(filter)\n          if (piece < 0) break\n          if (self._request(wire, piece, false)) return\n          tried[piece] = true\n          tries += 1\n        }\n      } else {\n        for (piece = next.to; piece >= next.from + next.offset; --piece) {\n          if (!wire.peerPieces.get(piece)) continue\n          if (self._request(wire, piece, false)) return\n        }\n      }\n    }\n\n    // TODO: wire failed to validate as useful; should we close it?\n    // probably not, since 'have' and 'bitfield' messages might be coming\n  }\n\n  function speedRanker () {\n    var speed = wire.downloadSpeed() || 1\n    if (speed > SPEED_THRESHOLD) return function () { return true }\n\n    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed\n    var tries = 10\n    var ptr = 0\n\n    return function (index) {\n      if (!tries || self.bitfield.get(index)) return true\n\n      var missing = self.pieces[index].missing\n\n      for (; ptr < self.wires.length; ptr++) {\n        var otherWire = self.wires[ptr]\n        var otherSpeed = otherWire.downloadSpeed()\n\n        if (otherSpeed < SPEED_THRESHOLD) continue\n        if (otherSpeed <= speed) continue\n        if (!otherWire.peerPieces.get(index)) continue\n        if ((missing -= otherSpeed * secs) > 0) continue\n\n        tries--\n        return false\n      }\n\n      return true\n    }\n  }\n\n  function shufflePriority (i) {\n    var last = i\n    for (var j = i; j < self._selections.length && self._selections[j].priority; j++) {\n      last = j\n    }\n    var tmp = self._selections[i]\n    self._selections[i] = self._selections[last]\n    self._selections[last] = tmp\n  }\n\n  function trySelectWire (hotswap) {\n    if (wire.requests.length >= maxOutstandingRequests) return true\n    var rank = speedRanker()\n\n    for (var i = 0; i < self._selections.length; i++) {\n      var next = self._selections[i]\n\n      var piece\n      if (self.strategy === 'rarest') {\n        var start = next.from + next.offset\n        var end = next.to\n        var len = end - start + 1\n        var tried = {}\n        var tries = 0\n        var filter = genPieceFilterFunc(start, end, tried, rank)\n\n        while (tries < len) {\n          piece = self._rarityMap.getRarestPiece(filter)\n          if (piece < 0) break\n\n          // request all non-reserved blocks in this piece\n          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}\n\n          if (wire.requests.length < maxOutstandingRequests) {\n            tried[piece] = true\n            tries++\n            continue\n          }\n\n          if (next.priority) shufflePriority(i)\n          return true\n        }\n      } else {\n        for (piece = next.from + next.offset; piece <= next.to; piece++) {\n          if (!wire.peerPieces.get(piece) || !rank(piece)) continue\n\n          // request all non-reserved blocks in piece\n          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}\n\n          if (wire.requests.length < maxOutstandingRequests) continue\n\n          if (next.priority) shufflePriority(i)\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Called periodically to update the choked status of all peers, handling optimistic\n * unchoking as described in BEP3.\n */\nTorrent.prototype._rechoke = function () {\n  var self = this\n  if (!self.ready) return\n\n  if (self._rechokeOptimisticTime > 0) self._rechokeOptimisticTime -= 1\n  else self._rechokeOptimisticWire = null\n\n  var peers = []\n\n  self.wires.forEach(function (wire) {\n    if (!wire.isSeeder && wire !== self._rechokeOptimisticWire) {\n      peers.push({\n        wire: wire,\n        downloadSpeed: wire.downloadSpeed(),\n        uploadSpeed: wire.uploadSpeed(),\n        salt: Math.random(),\n        isChoked: true\n      })\n    }\n  })\n\n  peers.sort(rechokeSort)\n\n  var unchokeInterested = 0\n  var i = 0\n  for (; i < peers.length && unchokeInterested < self._rechokeNumSlots; ++i) {\n    peers[i].isChoked = false\n    if (peers[i].wire.peerInterested) unchokeInterested += 1\n  }\n\n  // Optimistically unchoke a peer\n  if (!self._rechokeOptimisticWire && i < peers.length && self._rechokeNumSlots) {\n    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })\n    var optimistic = candidates[randomInt(candidates.length)]\n\n    if (optimistic) {\n      optimistic.isChoked = false\n      self._rechokeOptimisticWire = optimistic.wire\n      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION\n    }\n  }\n\n  // Unchoke best peers\n  peers.forEach(function (peer) {\n    if (peer.wire.amChoking !== peer.isChoked) {\n      if (peer.isChoked) peer.wire.choke()\n      else peer.wire.unchoke()\n    }\n  })\n\n  function rechokeSort (peerA, peerB) {\n    // Prefer higher download speed\n    if (peerA.downloadSpeed !== peerB.downloadSpeed) {\n      return peerB.downloadSpeed - peerA.downloadSpeed\n    }\n\n    // Prefer higher upload speed\n    if (peerA.uploadSpeed !== peerB.uploadSpeed) {\n      return peerB.uploadSpeed - peerA.uploadSpeed\n    }\n\n    // Prefer unchoked\n    if (peerA.wire.amChoking !== peerB.wire.amChoking) {\n      return peerA.wire.amChoking ? 1 : -1\n    }\n\n    // Random order\n    return peerA.salt - peerB.salt\n  }\n}\n\n/**\n * Attempts to cancel a slow block request from another wire such that the\n * given wire may effectively swap out the request for one of its own.\n */\nTorrent.prototype._hotswap = function (wire, index) {\n  var self = this\n\n  var speed = wire.downloadSpeed()\n  if (speed < Piece.BLOCK_LENGTH) return false\n  if (!self._reservations[index]) return false\n\n  var r = self._reservations[index]\n  if (!r) {\n    return false\n  }\n\n  var minSpeed = Infinity\n  var minWire\n\n  var i\n  for (i = 0; i < r.length; i++) {\n    var otherWire = r[i]\n    if (!otherWire || otherWire === wire) continue\n\n    var otherSpeed = otherWire.downloadSpeed()\n    if (otherSpeed >= SPEED_THRESHOLD) continue\n    if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue\n\n    minWire = otherWire\n    minSpeed = otherSpeed\n  }\n\n  if (!minWire) return false\n\n  for (i = 0; i < r.length; i++) {\n    if (r[i] === minWire) r[i] = null\n  }\n\n  for (i = 0; i < minWire.requests.length; i++) {\n    var req = minWire.requests[i]\n    if (req.piece !== index) continue\n\n    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)\n  }\n\n  self.emit('hotswap', minWire, wire, index)\n  return true\n}\n\n/**\n * Attempts to request a block from the given wire.\n */\nTorrent.prototype._request = function (wire, index, hotswap) {\n  var self = this\n  var numRequests = wire.requests.length\n  var isWebSeed = wire.type === 'webSeed'\n\n  if (self.bitfield.get(index)) return false\n\n  var maxOutstandingRequests = isWebSeed\n    ? Math.min(\n        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),\n        self.maxWebConns\n      )\n    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)\n\n  if (numRequests >= maxOutstandingRequests) return false\n  // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)\n\n  var piece = self.pieces[index]\n  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()\n\n  if (reservation === -1 && hotswap && self._hotswap(wire, index)) {\n    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()\n  }\n  if (reservation === -1) return false\n\n  var r = self._reservations[index]\n  if (!r) r = self._reservations[index] = []\n  var i = r.indexOf(null)\n  if (i === -1) i = r.length\n  r[i] = wire\n\n  var chunkOffset = piece.chunkOffset(reservation)\n  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)\n\n  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {\n    if (self.destroyed) return\n\n    // TODO: what is this for?\n    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })\n\n    if (r[i] === wire) r[i] = null\n\n    if (piece !== self.pieces[index]) return onUpdateTick()\n\n    if (err) {\n      self._debug(\n        'error getting piece %s (offset: %s length: %s) from %s: %s',\n        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,\n        err.message\n      )\n      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)\n      onUpdateTick()\n      return\n    }\n\n    self._debug(\n      'got piece %s (offset: %s length: %s) from %s',\n      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort\n    )\n\n    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()\n\n    var buf = piece.flush()\n\n    // TODO: might need to set self.pieces[index] = null here since sha1 is async\n\n    sha1(buf, function (hash) {\n      if (self.destroyed) return\n\n      if (hash === self._hashes[index]) {\n        if (!self.pieces[index]) return\n        self._debug('piece verified %s', index)\n\n        self.pieces[index] = null\n        self._reservations[index] = null\n        self.bitfield.set(index, true)\n\n        self.store.put(index, buf)\n\n        self.wires.forEach(function (wire) {\n          wire.have(index)\n        })\n\n        // We also check `self.destroyed` since `torrent.destroy()` could have been\n        // called in the `torrent.on('done')` handler, triggered by `_checkDone()`.\n        if (self._checkDone() && !self.destroyed) self.discovery.complete()\n      } else {\n        self.pieces[index] = new Piece(piece.length)\n        self.emit('warning', new Error('Piece ' + index + ' failed verification'))\n      }\n      onUpdateTick()\n    })\n  })\n\n  function onUpdateTick () {\n    process.nextTick(function () { self._update() })\n  }\n\n  return true\n}\n\nTorrent.prototype._checkDone = function () {\n  var self = this\n  if (self.destroyed) return\n\n  // are any new files done?\n  self.files.forEach(function (file) {\n    if (file.done) return\n    for (var i = file._startPiece; i <= file._endPiece; ++i) {\n      if (!self.bitfield.get(i)) return\n    }\n    file.done = true\n    file.emit('done')\n    self._debug('file done: ' + file.name)\n  })\n\n  // is the torrent done? (if all current selections are satisfied, or there are\n  // no selections, then torrent is done)\n  var done = true\n  for (var i = 0; i < self._selections.length; i++) {\n    var selection = self._selections[i]\n    for (var piece = selection.from; piece <= selection.to; piece++) {\n      if (!self.bitfield.get(piece)) {\n        done = false\n        break\n      }\n    }\n    if (!done) break\n  }\n  if (!self.done && done) {\n    self.done = true\n    self._debug('torrent done: ' + self.infoHash)\n    self.emit('done')\n  }\n  self._gcSelections()\n\n  return done\n}\n\nTorrent.prototype.load = function (streams, cb) {\n  var self = this\n  if (self.destroyed) throw new Error('torrent is destroyed')\n  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })\n\n  if (!Array.isArray(streams)) streams = [ streams ]\n  if (!cb) cb = noop\n\n  var readable = new MultiStream(streams)\n  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)\n\n  pump(readable, writable, function (err) {\n    if (err) return cb(err)\n    self.pieces.forEach(function (piece, index) {\n      self.pieces[index] = null\n      self._reservations[index] = null\n      self.bitfield.set(index, true)\n    })\n    self._checkDone()\n    cb(null)\n  })\n}\n\nTorrent.prototype.createServer = function (requestListener) {\n  if (typeof Server !== 'function') throw new Error('node.js-only method')\n  if (this.destroyed) throw new Error('torrent is destroyed')\n  var server = new Server(this, requestListener)\n  this._servers.push(server)\n  return server\n}\n\nTorrent.prototype.pause = function () {\n  if (this.destroyed) return\n  this._debug('pause')\n  this.paused = true\n}\n\nTorrent.prototype.resume = function () {\n  if (this.destroyed) return\n  this._debug('resume')\n  this.paused = false\n  this._drain()\n}\n\nTorrent.prototype._debug = function () {\n  var args = [].slice.call(arguments)\n  args[0] = '[' + this.client._debugId + '] [' + this._debugId + '] ' + args[0]\n  debug.apply(null, args)\n}\n\n/**\n * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,\n * the queue will usually have only one peer in it, except when there are too\n * many peers (over `this.maxConns`) in which case they will just sit in the\n * queue until another connection closes.\n */\nTorrent.prototype._drain = function () {\n  var self = this\n  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)\n  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||\n      self._numConns >= self.client.maxConns) {\n    return\n  }\n  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)\n\n  var peer = self._queue.shift()\n  if (!peer) return // queue could be empty\n\n  this._debug('tcp connect attempt to %s', peer.addr)\n\n  var parts = addrToIPPort(peer.addr)\n  var opts = {\n    host: parts[0],\n    port: parts[1]\n  }\n\n  var conn = peer.conn = net.connect(opts)\n\n  conn.once('connect', function () { peer.onConnect() })\n  conn.once('error', function (err) { peer.destroy(err) })\n  peer.startConnectTimeout()\n\n  // When connection closes, attempt reconnect after timeout (with exponential backoff)\n  conn.on('close', function () {\n    if (self.destroyed) return\n\n    // TODO: If torrent is done, do not try to reconnect after a timeout\n\n    if (peer.retries >= RECONNECT_WAIT.length) {\n      self._debug(\n        'conn %s closed: will not re-add (max %s attempts)',\n        peer.addr, RECONNECT_WAIT.length\n      )\n      return\n    }\n\n    var ms = RECONNECT_WAIT[peer.retries]\n    self._debug(\n      'conn %s closed: will re-add to queue in %sms (attempt %s)',\n      peer.addr, ms, peer.retries + 1\n    )\n\n    var reconnectTimeout = setTimeout(function reconnectTimeout () {\n      var newPeer = self._addPeer(peer.addr)\n      if (newPeer) newPeer.retries = peer.retries + 1\n    }, ms)\n    if (reconnectTimeout.unref) reconnectTimeout.unref()\n  })\n}\n\n/**\n * Returns `true` if string is valid IPv4/6 address.\n * @param {string} addr\n * @return {boolean}\n */\nTorrent.prototype._validAddr = function (addr) {\n  var parts\n  try {\n    parts = addrToIPPort(addr)\n  } catch (e) {\n    return false\n  }\n  var host = parts[0]\n  var port = parts[1]\n  return port > 0 && port < 65535 &&\n    !(host === '127.0.0.1' && port === this.client.torrentPort)\n}\n\nfunction getBlockPipelineLength (wire, duration) {\n  return 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH)\n}\n\nfunction getPiecePipelineLength (wire, duration, pieceLength) {\n  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength)\n}\n\n/**\n * Returns a random integer in [0,high)\n */\nfunction randomInt (high) {\n  return Math.random() * high | 0\n}\n\nfunction noop () {}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/file.js":"module.exports = File\n\nvar eos = require('end-of-stream')\nvar EventEmitter = require('events').EventEmitter\nvar FileStream = require('./file-stream')\nvar inherits = require('inherits')\nvar path = require('path')\nvar render = require('render-media')\nvar stream = require('readable-stream')\nvar streamToBlob = require('stream-to-blob')\nvar streamToBlobURL = require('stream-to-blob-url')\nvar streamToBuffer = require('stream-with-known-length-to-buffer')\n\ninherits(File, EventEmitter)\n\nfunction File (torrent, file) {\n  EventEmitter.call(this)\n\n  this._torrent = torrent\n  this._destroyed = false\n\n  this.name = file.name\n  this.path = file.path\n  this.length = file.length\n  this.offset = file.offset\n\n  this.done = false\n\n  var start = file.offset\n  var end = start + file.length - 1\n\n  this._startPiece = start / this._torrent.pieceLength | 0\n  this._endPiece = end / this._torrent.pieceLength | 0\n\n  if (this.length === 0) {\n    this.done = true\n    this.emit('done')\n  }\n}\n\nObject.defineProperty(File.prototype, 'downloaded', {\n  get: function () {\n    if (!this._torrent.bitfield) return 0\n    var downloaded = 0\n    for (var index = this._startPiece; index <= this._endPiece; ++index) {\n      if (this._torrent.bitfield.get(index)) {\n        // verified data\n        downloaded += this._torrent.pieceLength\n      } else {\n        // \"in progress\" data\n        var piece = this._torrent.pieces[index]\n        downloaded += (piece.length - piece.missing)\n      }\n    }\n    return downloaded\n  }\n})\n\nFile.prototype.select = function (priority) {\n  if (this.length === 0) return\n  this._torrent.select(this._startPiece, this._endPiece, priority)\n}\n\nFile.prototype.deselect = function () {\n  if (this.length === 0) return\n  this._torrent.deselect(this._startPiece, this._endPiece, false)\n}\n\nFile.prototype.createReadStream = function (opts) {\n  var self = this\n  if (this.length === 0) {\n    var empty = new stream.PassThrough()\n    process.nextTick(function () {\n      empty.end()\n    })\n    return empty\n  }\n\n  var fileStream = new FileStream(self, opts)\n  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {\n    fileStream._notify()\n  })\n  eos(fileStream, function () {\n    if (self._destroyed) return\n    if (!self._torrent.destroyed) {\n      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)\n    }\n  })\n  return fileStream\n}\n\nFile.prototype.getBuffer = function (cb) {\n  streamToBuffer(this.createReadStream(), this.length, cb)\n}\n\nFile.prototype.getBlob = function (cb) {\n  if (typeof window === 'undefined') throw new Error('browser-only method')\n  streamToBlob(this.createReadStream(), this._getMimeType(), cb)\n}\n\nFile.prototype.getBlobURL = function (cb) {\n  if (typeof window === 'undefined') throw new Error('browser-only method')\n  streamToBlobURL(this.createReadStream(), this._getMimeType(), cb)\n}\n\nFile.prototype.appendTo = function (elem, opts, cb) {\n  if (typeof window === 'undefined') throw new Error('browser-only method')\n  render.append(this, elem, opts, cb)\n}\n\nFile.prototype.renderTo = function (elem, opts, cb) {\n  if (typeof window === 'undefined') throw new Error('browser-only method')\n  render.render(this, elem, opts, cb)\n}\n\nFile.prototype._getMimeType = function () {\n  return render.mime[path.extname(this.name).toLowerCase()]\n}\n\nFile.prototype._destroy = function () {\n  this._destroyed = true\n  this._torrent = null\n}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/file-stream.js":"module.exports = FileStream\n\nvar debug = require('debug')('webtorrent:file-stream')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\ninherits(FileStream, stream.Readable)\n\n/**\n * Readable stream of a torrent file\n *\n * @param {File} file\n * @param {Object} opts\n * @param {number} opts.start stream slice of file, starting from this byte (inclusive)\n * @param {number} opts.end stream slice of file, ending with this byte (inclusive)\n */\nfunction FileStream (file, opts) {\n  stream.Readable.call(this, opts)\n\n  this.destroyed = false\n  this._torrent = file._torrent\n\n  var start = (opts && opts.start) || 0\n  var end = (opts && opts.end && opts.end < file.length)\n    ? opts.end\n    : file.length - 1\n\n  var pieceLength = file._torrent.pieceLength\n\n  this._startPiece = (start + file.offset) / pieceLength | 0\n  this._endPiece = (end + file.offset) / pieceLength | 0\n\n  this._piece = this._startPiece\n  this._offset = (start + file.offset) - (this._startPiece * pieceLength)\n\n  this._missing = end - start + 1\n  this._reading = false\n  this._notifying = false\n  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)\n}\n\nFileStream.prototype._read = function () {\n  if (this._reading) return\n  this._reading = true\n  this._notify()\n}\n\nFileStream.prototype._notify = function () {\n  var self = this\n\n  if (!self._reading || self._missing === 0) return\n  if (!self._torrent.bitfield.get(self._piece)) {\n    return self._torrent.critical(self._piece, self._piece + self._criticalLength)\n  }\n\n  if (self._notifying) return\n  self._notifying = true\n\n  var p = self._piece\n  self._torrent.store.get(p, function (err, buffer) {\n    self._notifying = false\n    if (self.destroyed) return\n    if (err) return self._destroy(err)\n    debug('read %s (length %s) (err %s)', p, buffer.length, err && err.message)\n\n    if (self._offset) {\n      buffer = buffer.slice(self._offset)\n      self._offset = 0\n    }\n\n    if (self._missing < buffer.length) {\n      buffer = buffer.slice(0, self._missing)\n    }\n    self._missing -= buffer.length\n\n    debug('pushing buffer of length %s', buffer.length)\n    self._reading = false\n    self.push(buffer)\n\n    if (self._missing === 0) self.push(null)\n  })\n  self._piece += 1\n}\n\nFileStream.prototype.destroy = function (onclose) {\n  this._destroy(null, onclose)\n}\n\nFileStream.prototype._destroy = function (err, onclose) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  if (!this._torrent.destroyed) {\n    this._torrent.deselect(this._startPiece, this._endPiece, true)\n  }\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (onclose) onclose()\n}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/rarity-map.js":"module.exports = RarityMap\n\n/**\n * Mapping of torrent pieces to their respective availability in the torrent swarm. Used\n * by the torrent manager for implementing the rarest piece first selection strategy.\n */\nfunction RarityMap (torrent) {\n  var self = this\n\n  self._torrent = torrent\n  self._numPieces = torrent.pieces.length\n  self._pieces = []\n\n  self._onWire = function (wire) {\n    self.recalculate()\n    self._initWire(wire)\n  }\n  self._onWireHave = function (index) {\n    self._pieces[index] += 1\n  }\n  self._onWireBitfield = function () {\n    self.recalculate()\n  }\n\n  self._torrent.wires.forEach(function (wire) {\n    self._initWire(wire)\n  })\n  self._torrent.on('wire', self._onWire)\n  self.recalculate()\n}\n\n/**\n * Get the index of the rarest piece. Optionally, pass a filter function to exclude\n * certain pieces (for instance, those that we already have).\n *\n * @param {function} pieceFilterFunc\n * @return {number} index of rarest piece, or -1\n */\nRarityMap.prototype.getRarestPiece = function (pieceFilterFunc) {\n  if (!pieceFilterFunc) pieceFilterFunc = trueFn\n\n  var candidates = []\n  var min = Infinity\n\n  for (var i = 0; i < this._numPieces; ++i) {\n    if (!pieceFilterFunc(i)) continue\n\n    var availability = this._pieces[i]\n    if (availability === min) {\n      candidates.push(i)\n    } else if (availability < min) {\n      candidates = [ i ]\n      min = availability\n    }\n  }\n\n  if (candidates.length > 0) {\n    // if there are multiple pieces with the same availability, choose one randomly\n    return candidates[Math.random() * candidates.length | 0]\n  } else {\n    return -1\n  }\n}\n\nRarityMap.prototype.destroy = function () {\n  var self = this\n  self._torrent.removeListener('wire', self._onWire)\n  self._torrent.wires.forEach(function (wire) {\n    self._cleanupWireEvents(wire)\n  })\n  self._torrent = null\n  self._pieces = null\n\n  self._onWire = null\n  self._onWireHave = null\n  self._onWireBitfield = null\n}\n\nRarityMap.prototype._initWire = function (wire) {\n  var self = this\n\n  wire._onClose = function () {\n    self._cleanupWireEvents(wire)\n    for (var i = 0; i < this._numPieces; ++i) {\n      self._pieces[i] -= wire.peerPieces.get(i)\n    }\n  }\n\n  wire.on('have', self._onWireHave)\n  wire.on('bitfield', self._onWireBitfield)\n  wire.once('close', wire._onClose)\n}\n\n/**\n * Recalculates piece availability across all peers in the torrent.\n */\nRarityMap.prototype.recalculate = function () {\n  var i\n  for (i = 0; i < this._numPieces; ++i) {\n    this._pieces[i] = 0\n  }\n\n  var numWires = this._torrent.wires.length\n  for (i = 0; i < numWires; ++i) {\n    var wire = this._torrent.wires[i]\n    for (var j = 0; j < this._numPieces; ++j) {\n      this._pieces[j] += wire.peerPieces.get(j)\n    }\n  }\n}\n\nRarityMap.prototype._cleanupWireEvents = function (wire) {\n  wire.removeListener('have', this._onWireHave)\n  wire.removeListener('bitfield', this._onWireBitfield)\n  if (wire._onClose) wire.removeListener('close', wire._onClose)\n  wire._onClose = null\n}\n\nfunction trueFn () {\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-webtorrent/node_modules/webtorrent/lib/server.js":"module.exports = Server\n\nvar arrayRemove = require('unordered-array-remove')\nvar http = require('http')\nvar mime = require('mime')\nvar pump = require('pump')\nvar rangeParser = require('range-parser')\nvar url = require('url')\n\nfunction Server (torrent, requestListener) {\n  var server = http.createServer(requestListener)\n\n  var sockets = []\n  var pendingReady = []\n  var closed = false\n\n  server.on('connection', onConnection)\n  server.on('request', onRequest)\n\n  var _close = server.close\n  server.close = function (cb) {\n    closed = true\n    server.removeListener('connection', onConnection)\n    server.removeListener('request', onRequest)\n    while (pendingReady.length) {\n      var onReady = pendingReady.pop()\n      torrent.removeListener('ready', onReady)\n    }\n    torrent = null\n    _close.call(server, cb)\n  }\n\n  server.destroy = function (cb) {\n    sockets.forEach(function (socket) {\n      socket.destroy()\n    })\n\n    // Only call `server.close` if user has not called it already\n    if (!cb) cb = function () {}\n    if (closed) process.nextTick(cb)\n    else server.close(cb)\n  }\n\n  function onConnection (socket) {\n    socket.setTimeout(36000000)\n    sockets.push(socket)\n    socket.once('close', function () {\n      arrayRemove(sockets, sockets.indexOf(socket))\n    })\n  }\n\n  function onRequest (req, res) {\n    var pathname = url.parse(req.url).pathname\n\n    if (pathname === '/favicon.ico') {\n      return serve404Page()\n    }\n\n    // Allow CORS requests to read responses\n    if (req.headers.origin) {\n      res.setHeader('Access-Control-Allow-Origin', req.headers.origin || '*')\n    }\n\n    // Prevent browser mime-type sniffing\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n\n    // Allow CORS requests to specify arbitrary headers, e.g. 'Range',\n    // by responding to the OPTIONS preflight request with the specified\n    // origin and requested headers.\n    if (req.method === 'OPTIONS') {\n      return serveOptionsRequest()\n    }\n\n    if (req.method === 'GET' || req.method === 'HEAD') {\n      if (torrent.ready) {\n        handleRequest()\n      } else {\n        pendingReady.push(onReady)\n        torrent.once('ready', onReady)\n      }\n      return\n    }\n\n    return serveMethodNotAllowed()\n\n    function serveOptionsRequest () {\n      res.statusCode = 204 // no content\n      res.setHeader('Access-Control-Max-Age', '600')\n      res.setHeader('Access-Control-Allow-Methods', 'GET,HEAD,PUT,PATCH,POST,DELETE')\n\n      if (req.headers['access-control-request-headers']) {\n        res.setHeader(\n          'Access-Control-Allow-Headers',\n          req.headers['access-control-request-headers']\n        )\n      }\n      res.end()\n    }\n\n    function onReady () {\n      arrayRemove(pendingReady, pendingReady.indexOf(onReady))\n      handleRequest()\n    }\n\n    function handleRequest () {\n      if (pathname === '/') {\n        return serveIndexPage()\n      }\n\n      var index = Number(pathname.split('/')[1])\n      if (Number.isNaN(index) || index >= torrent.files.length) {\n        return serve404Page()\n      }\n\n      var file = torrent.files[index]\n      serveFile(file)\n    }\n\n    function serveIndexPage () {\n      res.statusCode = 200\n      res.setHeader('Content-Type', 'text/html')\n\n      var listHtml = torrent.files.map(function (file, i) {\n        return '<li><a download=\"' + file.name + '\" href=\"/' + i + '/' + file.name + '\">' + file.path + '</a> ' +\n          '(' + file.length + ' bytes)</li>'\n      }).join('<br>')\n\n      var html = getPageHTML(\n        torrent.name + ' - WebTorrent',\n        '<h1>' + torrent.name + '</h1><ol>' + listHtml + '</ol>'\n      )\n      res.end(html)\n    }\n\n    function serve404Page () {\n      res.statusCode = 404\n      res.setHeader('Content-Type', 'text/html')\n\n      var html = getPageHTML('404 - Not Found', '<h1>404 - Not Found</h1>')\n      res.end(html)\n    }\n\n    function serveFile (file) {\n      res.statusCode = 200\n      res.setHeader('Content-Type', mime.lookup(file.name))\n\n      // Support range-requests\n      res.setHeader('Accept-Ranges', 'bytes')\n\n      // Set name of file (for \"Save Page As...\" dialog)\n      res.setHeader(\n        'Content-Disposition',\n        'inline; filename*=UTF-8\\'\\'' + encodeRFC5987(file.name)\n      )\n\n      // Support DLNA streaming\n      res.setHeader('transferMode.dlna.org', 'Streaming')\n      res.setHeader(\n        'contentFeatures.dlna.org',\n        'DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000'\n      )\n\n      // `rangeParser` returns an array of ranges, or an error code (number) if\n      // there was an error parsing the range.\n      var range = rangeParser(file.length, req.headers.range || '')\n\n      if (Array.isArray(range)) {\n        res.statusCode = 206 // indicates that range-request was understood\n\n        // no support for multi-range request, just use the first range\n        range = range[0]\n\n        res.setHeader(\n          'Content-Range',\n          'bytes ' + range.start + '-' + range.end + '/' + file.length\n        )\n        res.setHeader('Content-Length', range.end - range.start + 1)\n      } else {\n        range = null\n        res.setHeader('Content-Length', file.length)\n      }\n\n      if (req.method === 'HEAD') {\n        return res.end()\n      }\n\n      pump(file.createReadStream(range), res)\n    }\n\n    function serveMethodNotAllowed () {\n      res.statusCode = 405\n      res.setHeader('Content-Type', 'text/html')\n      var html = getPageHTML('405 - Method Not Allowed', '<h1>405 - Method Not Allowed</h1>')\n      res.end(html)\n    }\n  }\n\n  return server\n}\n\nfunction getPageHTML (title, pageHtml) {\n  return '<!DOCTYPE html><html lang=\"en\"><head>' +\n    '<meta charset=\"utf-8\">' +\n    '<title>' + title + '</title>' +\n    '</head><body>' + pageHtml + '</body></html>'\n}\n\n// From https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\nfunction encodeRFC5987 (str) {\n  return encodeURIComponent(str)\n    // Note that although RFC3986 reserves \"!\", RFC5987 does not,\n    // so we do not need to escape it\n    .replace(/['()]/g, escape) // i.e., %27 %28 %29\n    .replace(/\\*/g, '%2A')\n    // The following are not required for percent-encoding per RFC5987,\n    // so we can allow for a little better readability over the wire: |`^\n    .replace(/%(?:7C|60|5E)/g, unescape)\n}\n"}